[
["index.html", "Curso Data Wrangling con R 1 Objetivo y Requisitos 1.1 Objetivo 1.2 Requisitos 1.3 Temario", " Curso Data Wrangling con R Jhosse Paul Márquez Ruíz Fernando Daniel Hernández Sánchez 1 Objetivo y Requisitos 1.1 Objetivo Este curso se enfocará a la utilización de R, bajo la filosofía tidy data, para la extracción, transformación y exportación de datos desde diferentes fuentes: CSV EXCEL TXT Otros Pretendemos ayudarles a conocer una herramienta más, que les facilite el manejo de información (tablas dinámicas, conteos y resúmenes de datos), de una manera más eficiente. Para poder aprovechar el curso es necesario tener la disposición de aprender algo nuevo y un pequeño background de programación: Haber hecho una macro. Utilizar funciones de BUSCARV, BUSCARH, etc… Realizar tablas dinámicas en excel. 1.2 Requisitos R (&gt; 3.5) RStudio data.table lubridate magrittr 1.3 Temario Semana 1: R y RStudio Introducción a R ¿Por qué usar R? Benchmark (Excel vs R) Runtime Reproducibilidad Operaciones básicas Instalación Instalación del interprete Instalación de RStudio Instalación de paquetes Tour por RStudio Panel de Script Panel de código Environment Paneles misc. Semana 2: Estructuras de datos Atomic vectors Vectors Matrix &amp; Arrays Lists data.frame, data.table Semana 3: Funciones functions Operaciones vectoriales Operaciones matriciales Extractores Composición de funciones Semana 4: Importar/Exportar datos read.table read.csv fread readxl openxlsx rio Semana 5: Tidy data &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD Tidy data Wide and Long data dcast y melt 1.3 merge, rbind, cbind Tidy data Wide data Long data dcast y melt merge, rbind, cbind &gt;&gt;&gt;&gt;&gt;&gt;&gt; 9ba4b0952f4acdbe330840610a902b21e6ff58e2 Semana 6: Introducción a data.table Eficiencia de data.table, copy y punteros Filter Select Group by Update Semana 7: Repaso y ejercicios GRID FOVISSSTE histórico Semana 8: Manipulación avanzada Manipulación de fechas SDcols Agregaciones complejas Forma funcional de asignación Variables especiales "],
["r-y-rstudio.html", "2 R y RStudio 2.1 Instalación 2.2 Tour por RStudio", " 2 R y RStudio 2.0.1 ¿Qué es R? “R es un lenguaje de programación interpretado, de distribución libre, bajo Licencia GNU, y se mantiene en un ambiente para el cómputo estadístico y gráfico…” Destacando que: Interpretado: No hay compilación. El lenguaje tiene un REPL donde se puede ejecutar el código directamente. Distribución libre: Se distribuye bajo una licensia (GPL-3)gpl. No tiene ningún costo ni garantía. Además es bueno notar las siguientes características del lenguaje: Debilmente tipado: No existen definiciones formales de tipo de dato. Los tipos primitivos se heredan directamente de los tipos fundamentales de C. Dinámicamente tipado: No hay declaración de tipo de datos, por lo tanto, no tienen un tipo fijo y puede ser cohercionado. Lenguaje fundamentalmente funcional, aunque tiene soporte para procedural y orientado a objetos. Es la primera opción de publicación de nuevos métodos estadísticos por la académia. Estas características le otorgan una posición intermedia entre usabilidad y performance que ha sido muy valorada por la comunidad estadística. La sintáxis del lenguaje es muy intuitiva y orientada a los datos. Además, cuenta con un amplio soporte para visualización de datos. Por los estas razones es considerada la lingua franca del análisis estadístico. Otros lenguajes que compiten en este ámbito con R son, Python, Scala, C++ y Julia, cada uno con diferentes características y particularidades. 2.0.2 ¿Por qué y cuando usar R? R es una excelente opción cuando se requiere análisis estadístico, performance intermedio, o bien, cuando se requieren hacer visualizaciones de datos estáticas. En cambio, se debe evitar R si se require: Muchos datos (&gt; 16GB). Desarrollo web. Experiencia de usuario. Alto performance. Debido a que es un lenguaje interpretado, débilmente y dinámicamente tipado, el tiempo de desarrollo de un programa simple que ejecute acciones concretas es mucho menor que el tiempo de desarrollo en un lenguaje más formal, como Java o C++. A cambio de esto, el performance de R es mucho menor que un lenguaje compilado, y es incluso menor que el de otros lenguajes interpretados. Para solventar esto, R tiene soporte para generar nuestras funciones en otros lenguajes (C, Java, C++, Fortran, Python) y ejecutarlas dentro del runtime de R, aunque este procedimiento escapa por mucho el alcance de este curso. A pesar de que el performance de R no es competencia para otros lenguajes, supera por mucho a otras herramientas gráficas como Excel y Access. Adicional al performance, existe una clara ventaja de cambiar nuestro esquema de trabajo de una interfaz gráfica a un lenguaje de programación y es la reproducibilidad, es decir, las instrucciones escritas de un procedimiento son siempre más eficientes que el uso del mouse, ya que generan menos errores por parte del usuario. Acompañando a la reproducibilidad, tenemos el control de versiones, ya que podemos detectar la historia de los cambios en las cosas escritas. 2.0.3 Benchmark 2.0.3.1 Runtime 2.0.3.2 Reproducibilidad y control de versiones. En HiTo tenemos nuestra propia plataforma de control de versiones para código. Para EXCEL tenemos que hacer “respaldos” periódicamente. 2.1 Instalación 2.1.1 Instalación del interprete Todos los detalles de la instalación están incluídos en el portal (CRAN)cran. A continuación les dejamos un resumen para los principales sistemas operativos: 2.1.1.1 Windows Entrar a (CRAN)cran. Seguir el link (Download R for Windows)download_cran. Seguir el link (base)cran_base. Descargar la última versión de R en el (link)download_r. Ejecutar el instalador con las opciones default. 2.1.2 Instalación de RStudio Entrar a la (página de descarga de RStudio)rstudio. Descargar la última versión de (Rstudio para Windows)download_rstudio Ejecutar el instalador con las opciones default. 2.1.3 Instalación de paquetes Una vez que se tiene instalado el environment de R, podemos instalar las paqueterías de diferentes formas. En este curso detallamos la instalación desde RStudio y desde la CLI. Ambos métodos requieren conexión a internet. 2.1.3.1 Instalación desde la CLI Básicamente todo se encuentra detallado en la documentación de la función install.packages. Nosotros nos limitaremos a usar su funcionalidad básica. Para ello abrimos una consola de R y escribimos el siguiente comando install.packages(c(&quot;data.table&quot;, &quot;magrittr&quot;, &quot;lubridate&quot;)) 2.1.3.2 Instalación desde RStudio Hay dos métodos: Ir a la sección Packages (Ctrl + 7). Click en Install. En el input field Packages escribir el nombre de los paquetes requeridos. Click en el botón de Install. O bien: Ir al menu Tools. Ir a la opción Install packages…. En el input field Packages escribir el nombre de los paquetes requeridos. Click en el botón de Install. 2.2 Tour por RStudio RStudio es un IDE (Integrated Development Environment) para R. Es decir, es una interfaz gráfica amigable para el desarrollo de código de R, e.g. integración con control de versiones, integración con paquetes de desarrollo, esqueletos y boilerplates, shortcuts, code highlight, integración con compiladores, linting, integración con bases de datos, paneles para gráficos estáticos e interactivos, adminsitración de paquetes, entre otras facilidades. 2.2.1 Panel del CLI Este panel es una sesión de R y podemos ejecutar cualquier comando directamente en ella. Para enfocarla usamos el shortcut CTRL + 2, 2.2.2 Panel de script Podemos crear un script nuevo con Ctrl + Shift + N, o bien, enfocar el script actual con Ctrl + 1. Una vez en el script, podemos enviar el código de un bloque al CLI con CTRL + ENTER. 2.2.3 Environment Las variables declaradas en la sesión están listadas en el environment. Podemos enfocarlo con CTRL + 8. 2.2.4 Paneles miscelaneos Otros paneles en RStudio son: Files: Nos permite ver los archivos del proyecto, renombrarlos y eliminarlos. Plots: Visualizaciones estáticas. Packages: Administración de paquetes. Instalar, remover, actualizar. Help: Sistema de ayuda. Viewer: Visualizaciones interactivas. History: Historial de comandos ejecutados. Connections: Conexiones a bases de datos. Build: Estatus de compilaciones. Git: Sistema de control de versiones. Terminal: CLI del sistema operativo. Jobs: Tareas en segundo plano.. Algunos solo se encuentran disponibles dentro de proyectos. 2.2.5 Sistema de ayuda Se puede acceder al sistema de ayuda con los siguientes méetodos: En el panel Help (CTRL + 3). Colocando el cursor sobre una función y apretando F1. Con la función de ayuda ? o búsqueda en la ayuda ??. La documentación de R es muy completa y en cada página de ayuda se detalla para que sirve cada función, cuales son sus argumentos y cual es el output esperado. Por ejemplo, ejecutar el siguiente comando en la consola: ?c O bien: ??vector "],
["estructuras-de-datos.html", "3 Estructuras de datos 3.1 Operadores binarios 3.2 Asignación de variables 3.3 Vectors 3.4 Coherción 3.5 Matrix &amp; Arrays 3.6 Lists 3.7 data.frame, data.table", " 3 Estructuras de datos 3.1 Operadores binarios Las operaciones binarias funcionan como en todos los lenguajes: 3 + 3 ## [1] 6 3 - 3 ## [1] 0 3 * 3 ## [1] 9 3 / 3 ## [1] 1 4 %/% 3 ## [1] 1 3 ^ 3 ## [1] 27 3 == 3 ## [1] TRUE 2 &gt; 3 ## [1] FALSE 1 &lt;= 0 ## [1] FALSE -1 &gt; -5 ## [1] TRUE 3 != 2 ## [1] TRUE TRUE | FALSE ## [1] TRUE TRUE &amp; FALSE ## [1] FALSE Sin embargo, R generaliza el concepto de operador binario a otras estructuras de datos. Este tema lo analizaremos a profundidad más adelante. A modo de ejemplo: c(1, 2, 3) + 1:3 ## [1] 2 4 6 1:10 + 1:2 ## [1] 2 4 4 6 6 8 8 10 10 12 3.2 Asignación de variables Podemos hacer que un valor se almacene de manera persistente en la memoria RAM asignandola a un environment. Para ello simplemente usamos el operador de asignación, &lt;-: x &lt;- 2 y &lt;- 3 x * y ## [1] 6 z &lt;- x ^ y z ## [1] 8 Existen otros operadores de asingación, sin embargo, estos no son recomendables en las mejores prácticas de programación en R, por lo que no se detallan en este curso. La manipulación de environments escapa de los objetivos del curso 3.3 Vectors Los vectores y las listas son las estructuras fundamentales en R. A partir de ellas se construyen todas las demás estructuras de datos más complejas. A pesar de que en R no existen tipos, la implementación de R requiere que existan clases base, para que el interprete pueda usar los métodos correctos sobre la variable declarada. logical_vector &lt;- TRUE class(logical_vector) ## [1] &quot;logical&quot; integer_vector &lt;- 1L class(integer_vector) ## [1] &quot;integer&quot; numeric_vector &lt;- 1 class(numeric_vector) ## [1] &quot;numeric&quot; complex_vector &lt;- 0.5 + 2i class(complex_vector) ## [1] &quot;complex&quot; character_vector &lt;- &quot;a&quot; class(character_vector) ## [1] &quot;character&quot; raw_vector &lt;- raw(&quot;1&quot;) class(raw_vector) ## [1] &quot;raw&quot; Los vectores tienen tres atributos relevantes: typeof, el tipo con el que se almacenan los datos en RAM. Este tipo es análogo a C. length, la cantidad de elementos que componen al vector. attributes, metadatos arbitrarios. Para crear vectores con más de un elemento, se usa la función c (combine). logical_vector &lt;- c(T, FALSE, F, TRUE) integer_vector &lt;- 1:10 numeric_vector &lt;- c(2.7182, 1.6180, 3.1416) character_vector &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) R introduce un tipo derivado de los anteriores, el factor. Esta clase combina un integer vector con una tabla de nombres, que es un vector character. Esto funciona para poder generar datos con etiquetas sin ocupar mayor espacio en memoria (los integer ocupan menos memoria que los character): factor(c(1, 2, 1, 1, 2, 1, 2), levels = c(1, 2), labels = c(&quot;male&quot;, &quot;female&quot;)) ## [1] male female male male female male female ## Levels: male female 3.4 Coherción Como ya se mencionó, R es un lenguaje debilmente y dinámicamente tipado, en consecuencia, cualquier valor puede ser comparado con otro: &quot;3&quot; == 3 ## [1] TRUE 1 == TRUE ## [1] TRUE Aún más, cualquier valor puede ser combinado con cualquier otro: c(&quot;a&quot;, 1, 1L, TRUE) ## [1] &quot;a&quot; &quot;1&quot; &quot;1&quot; &quot;TRUE&quot; Esta característica es un error muy común para los principiantes en el lenguaje. Sobre todo en el uso de vectores factor. factor_vector &lt;- factor( x = c(1, 2, 3, 1, 2, 3), levels = c(1, 2, 3), labels = c(3, 2, 1) ) as.character(factor_vector) == 1 ## [1] FALSE FALSE TRUE FALSE FALSE TRUE as.integer(factor_vector) == 1 ## [1] TRUE FALSE FALSE TRUE FALSE FALSE Es por eso que se procura evitar la función factor hasta tener un conocimiento más profundo de las estructuras de datos. La regla de coherción es siempre convertir los tipos al tipos más general posible, en orden de prioridad: logical &lt; integer &lt; double &lt; character Finalmente, podemos cohercionar de manera explícita nuestros datos con la familia de funciones as.*, como se vió en ejemplo anterior. 3.5 Matrix &amp; Arrays La primera generalización de un vector, es aumentar la cantidad de dimensiones que puede tener. Para ello existe la estructura matrix: m &lt;- matrix(1:9, nrow = 3, ncol = 3) m ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 m2 &lt;- matrix(10:18, 3, 3) m2 ## [,1] [,2] [,3] ## [1,] 10 13 16 ## [2,] 11 14 17 ## [3,] 12 15 18 Para cualquier generalización a dimensiones superiores tenemos los array: a &lt;- array(1:125, dim = c(5, 5, 5)) a ## , , 1 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 6 11 16 21 ## [2,] 2 7 12 17 22 ## [3,] 3 8 13 18 23 ## [4,] 4 9 14 19 24 ## [5,] 5 10 15 20 25 ## ## , , 2 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 26 31 36 41 46 ## [2,] 27 32 37 42 47 ## [3,] 28 33 38 43 48 ## [4,] 29 34 39 44 49 ## [5,] 30 35 40 45 50 ## ## , , 3 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 51 56 61 66 71 ## [2,] 52 57 62 67 72 ## [3,] 53 58 63 68 73 ## [4,] 54 59 64 69 74 ## [5,] 55 60 65 70 75 ## ## , , 4 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 76 81 86 91 96 ## [2,] 77 82 87 92 97 ## [3,] 78 83 88 93 98 ## [4,] 79 84 89 94 99 ## [5,] 80 85 90 95 100 ## ## , , 5 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 101 106 111 116 121 ## [2,] 102 107 112 117 122 ## [3,] 103 108 113 118 123 ## [4,] 104 109 114 119 124 ## [5,] 105 110 115 120 125 Del mismo modo que con los vectores, R está diseñado para soportar los operadores binarios de manera directa sobre estas estructuras de datos: 5 * a ## , , 1 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 5 30 55 80 105 ## [2,] 10 35 60 85 110 ## [3,] 15 40 65 90 115 ## [4,] 20 45 70 95 120 ## [5,] 25 50 75 100 125 ## ## , , 2 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 130 155 180 205 230 ## [2,] 135 160 185 210 235 ## [3,] 140 165 190 215 240 ## [4,] 145 170 195 220 245 ## [5,] 150 175 200 225 250 ## ## , , 3 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 255 280 305 330 355 ## [2,] 260 285 310 335 360 ## [3,] 265 290 315 340 365 ## [4,] 270 295 320 345 370 ## [5,] 275 300 325 350 375 ## ## , , 4 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 380 405 430 455 480 ## [2,] 385 410 435 460 485 ## [3,] 390 415 440 465 490 ## [4,] 395 420 445 470 495 ## [5,] 400 425 450 475 500 ## ## , , 5 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 505 530 555 580 605 ## [2,] 510 535 560 585 610 ## [3,] 515 540 565 590 615 ## [4,] 520 545 570 595 620 ## [5,] 525 550 575 600 625 m * m2 ## [,1] [,2] [,3] ## [1,] 10 52 112 ## [2,] 22 70 136 ## [3,] 36 90 162 m %*% m2 ## [,1] [,2] [,3] ## [1,] 138 174 210 ## [2,] 171 216 261 ## [3,] 204 258 312 Realmente las matrices son arrays de dimension 2. Ambas estructuras generalizan el concepto de length a dim. 3.6 Lists Las listas son una generalización, en otro sentido, de los vectores. Un vector tiene la limitante de ser una estructura flat y que todos los elementos que almacena son de la misma clase. Las listas no tienen estas dos restricciones. Cada elemento de una lista puede ser de diferente clase, incluyendo listas, e.g: list( list(1, &quot;a&quot;, 5L), raw(0), list( list( list(NA) ) ) ) ## [[1]] ## [[1]][[1]] ## [1] 1 ## ## [[1]][[2]] ## [1] &quot;a&quot; ## ## [[1]][[3]] ## [1] 5 ## ## ## [[2]] ## raw(0) ## ## [[3]] ## [[3]][[1]] ## [[3]][[1]][[1]] ## [[3]][[1]][[1]][[1]] ## [1] NA También podemos nombrar los elementos de una lista con la finalidad de ocupar los nombres para extraer los datos. list( numeric_vectors = list( numeric_vector = numeric_vector, integer_vector = integer_vector, complex_vector = complex_vector ), character_vector = character_vector, raw_vector = raw_vector ) ## $numeric_vectors ## $numeric_vectors$numeric_vector ## [1] 2.7182 1.6180 3.1416 ## ## $numeric_vectors$integer_vector ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## $numeric_vectors$complex_vector ## [1] 0.5+2i ## ## ## $character_vector ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ## ## $raw_vector ## [1] 00 3.7 data.frame, data.table Un data.frame es una forma especial de lista con la restricción de que todos los elementos de la lista tengan la misma longitud, e.g. random_numbers &lt;- list( uniform_vector = runif(10), normal_vector = rnorm(10), geometric_vector = rgeom(10, 0.1) ) as.data.frame(random_numbers) ## uniform_vector normal_vector geometric_vector ## 1 0.884599914 -0.84156896 17 ## 2 0.161589777 0.73209818 36 ## 3 0.649313667 -0.88216531 8 ## 4 0.712934565 0.68611816 7 ## 5 0.946912116 -0.99506880 1 ## 6 0.850465824 -1.31742977 1 ## 7 0.205348171 -1.88739605 3 ## 8 0.008127087 0.03314262 2 ## 9 0.622115838 0.99694104 0 ## 10 0.762887654 -0.03755956 5 O simplemente: data.frame( uniform_vector = runif(10), normal_vector = rnorm(10), geometric_vector = rgeom(10, 0.1) ) ## uniform_vector normal_vector geometric_vector ## 1 0.422537909 -2.38989428 4 ## 2 0.205270816 -0.74800284 21 ## 3 0.553747768 -0.09023079 11 ## 4 0.112354198 -0.59894637 50 ## 5 0.522242753 0.31278473 19 ## 6 0.807584558 -0.42222387 1 ## 7 0.830759862 -0.56500871 2 ## 8 0.338709657 -0.24628471 1 ## 9 0.634366973 0.92643609 1 ## 10 0.007407494 -2.42464017 12 Esta estructura de datos va a ser la principal forma de traducir nuestra forma de pensar a R, ya que es lo más cercano a una spreadsheet. En este caso, cada columna es una variable o dimensión y es un elemento de una lista. La librería data.table presenta una forma especial de los data.frame con muchísimas mejoras. Este curso se trata básicamente de como manipular estas estructuras de datos y conocer las ventajas de usar data.table. "],
["funciones.html", "4 Funciones 4.1 Composicion de funciones 4.2 Vocabulario 4.3 Extractores", " 4 Funciones Las funciones son el componente fundamental de la programación en R. En este curso no nos enfocarémos en como crear funciones, sino como usarlas. Una función es un bloque de código que ejecuta la lógica deseada. Para ello, hay que definir un flujo de información que realice las operaciones que deseemos llevar a cabo sobre los datos. Además, las funciones pueden tener inputs de información, los cuales son llamados argumentos. Por ejemplo: f &lt;- function(x) { print(x + 1) } formals(f) ## $x body(f) ## { ## print(x + 1) ## } f ## function(x) { ## print(x + 1) ## } f(1) ## [1] 2 Como se puede ver en el ejemplo de arriba, no basta con escribir el nombre de la función f para invocarla, sino que se tiene que colocar un par de paréntesis inmediatamente después de la función. Las funciones pueden tener argumentos obligados y argumentos opcionales, e.g. f &lt;- function(x, y = 1) { print(x + y) } f(1) ## [1] 2 Finalmente, las funciones pueden recibir los argumentos de manera nombrada y de manera posicional. f &lt;- function(x, y, z) { x / y / z } f(1, 2, 3) ## [1] 0.1666667 f(1, z = 2, y = 3) ## [1] 0.1666667 f(z = 1, 2, x = 3) ## [1] 1.5 4.1 Composicion de funciones La composición de funciones está definida de la siguiente manera: \\[g \\circ f = g(f(x))\\] En R, la composición de funciones está provista por la librería magrittr. El operador %&gt;% es el operador de composición de funciones definido de la siguiente manera: \\[f(x) %&gt;% g = g(f(x))\\] Esto nos permite ejecutar funciones de manera continua sin perder facilidad de lectura en nuestro código, e.g. library(magrittr) 1:10 %&gt;% add(100) %&gt;% divide_by(10) %&gt;% multiply_by(10) %&gt;% subtract(100) ## [1] 1 2 3 4 5 6 7 8 9 10 En todas las secciones subsecuentes usaremos esta notación para nuestros ejemplos. 4.2 Vocabulario En general, todas las funciones matetmáticas están definidas para vectores y matrices. A continuación listamos algunas de ellas: sin, cos, tan, acos, asin, atan, atan2 sum, prod, max, min, range, pmax, pmin cumsum, cumprod, cummax, cummin abs, log, exp, sign floor, ceil, round, trunc, signif mean, median, cor, sd, var, sample, seq, rep, rev Adicional, tenemos el operador secuencia de enteros :. 4.3 Extractores Sabemos que todo es una función en R. Y sabemos que las estructuras de datos fundamentales son los vectores y la listas. Entonces procedemos a explicar como usar funciones para extraer datos de las estructuras fundamentales. Para extraer datos de un vector ocupamos la función [(x) como en todos los demás lenguajes de programación, donde x es el índice del elemento que queremos extraer, iniciando en 1. Es común que desarrolladores de otros lenguajes de programación encuentren extraña esta notación, ya que generalmente un índice inicia en 0. x puede ser un vector de índices, en ese caso de devuelve un subvector con los elementos de las posiciones solicitadas: integer_vector &lt;- 1:10 * 100 integer_vector[1] ## [1] 100 integer_vector[2:5] ## [1] 200 300 400 500 integer_vector[c(3, 5, 6, 8, 1)] ## [1] 300 500 600 800 100 Para extraer datos de una lista podemos ocupar la función [, la cual devolverá una lista con los elementos de las posiciones solicitadas, o bien, la función [[ para extraer un elemento de la lista. Debido a la naturaleza de las listas, podemos ocupar múltiples funciones de extractor para obtener elementos anidados: example_list &lt;- list( list( 1:10, runif(10), rnorm(10) ), letters[1:10] ) example_list[2] ## [[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; class(example_list[2]) ## [1] &quot;list&quot; example_list[2][5] ## [[1]] ## NULL example_list[[1]][[2]][1] ## [1] 0.6726164 En el caso de que un vector o una lista tengan nombres, podemos usar el nombre en la función [ o en listas, usar directamente el extractor $: named_vector &lt;- c(&quot;uno&quot; = 1, &quot;dos&quot; = 2, &quot;tres&quot; = 3) named_vector[&quot;uno&quot;] ## uno ## 1 named_list &lt;- list( numeric_vectors = list( integer_vector = c(1, 2, 3, 4, 5, 6, 7 ,8, 9, 0), uniform_random = runif(10), normal_random = rnorm(10) ), character_vector = letters[1:10] ) named_list[[&quot;numeric_vectors&quot;]]$integer_vector ## [1] 1 2 3 4 5 6 7 8 9 0 Para matrix, array, data.frame y data.table, la función [ se comporta de manera diferente. Para empezar, puede recibir tantos argumentos como dimensiones tenga el array, en el caso de data.frame y matrix, recibe dos argumentos. El primero es la posición que queremos extraer en la primera dimensión (filas), el segundo es la posición que queremos extraer en la segunda dimensión (columnas). En caso de ser omitida una dimensión, se toma todos los valores posibles, e.g. iris[1, 1] ## [1] 5.1 iris[1:5, 1:5] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa iris[1, ] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa iris[, 1] ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 ## [18] 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 ## [35] 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 ## [52] 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 ## [69] 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 ## [86] 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 ## [103] 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 ## [120] 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 ## [137] 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9 iris3[1, 1:4, 3] ## Sepal L. Sepal W. Petal L. Petal W. ## 6.3 3.3 6.0 2.5 iris3[, , 1] [1, ][1] ## Sepal L. ## 5.1 Siendo el data.frame una lista nombrada, también podemos ocupar el operador $: iris$Species ## [1] setosa setosa setosa setosa setosa setosa ## [7] setosa setosa setosa setosa setosa setosa ## [13] setosa setosa setosa setosa setosa setosa ## [19] setosa setosa setosa setosa setosa setosa ## [25] setosa setosa setosa setosa setosa setosa ## [31] setosa setosa setosa setosa setosa setosa ## [37] setosa setosa setosa setosa setosa setosa ## [43] setosa setosa setosa setosa setosa setosa ## [49] setosa setosa versicolor versicolor versicolor versicolor ## [55] versicolor versicolor versicolor versicolor versicolor versicolor ## [61] versicolor versicolor versicolor versicolor versicolor versicolor ## [67] versicolor versicolor versicolor versicolor versicolor versicolor ## [73] versicolor versicolor versicolor versicolor versicolor versicolor ## [79] versicolor versicolor versicolor versicolor versicolor versicolor ## [85] versicolor versicolor versicolor versicolor versicolor versicolor ## [91] versicolor versicolor versicolor versicolor versicolor versicolor ## [97] versicolor versicolor versicolor versicolor virginica virginica ## [103] virginica virginica virginica virginica virginica virginica ## [109] virginica virginica virginica virginica virginica virginica ## [115] virginica virginica virginica virginica virginica virginica ## [121] virginica virginica virginica virginica virginica virginica ## [127] virginica virginica virginica virginica virginica virginica ## [133] virginica virginica virginica virginica virginica virginica ## [139] virginica virginica virginica virginica virginica virginica ## [145] virginica virginica virginica virginica virginica virginica ## Levels: setosa versicolor virginica Finalmente, el operador [ tiene una funcionalidad especial en data.table, cumpliendo con la mayoría de las operaciones que verémos a lo largo del curso. En este momento nos limitaremos únicamente a ver las diferencias con data.frame: library(data.table) dtiris &lt;- as.data.table(iris) class(dtiris) ## [1] &quot;data.table&quot; &quot;data.frame&quot; # 1. El primer argumento del extractor en data.table siempre extrae filas iris[2] %&gt;% head ## Sepal.Width ## 1 3.5 ## 2 3.0 ## 3 3.2 ## 4 3.1 ## 5 3.6 ## 6 3.9 dtiris[1] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1: 5.1 3.5 1.4 0.2 setosa # 2. Cuando el segundo argumento es un nombre, no se requieren comillas iris[, &quot;Species&quot;] ## [1] setosa setosa setosa setosa setosa setosa ## [7] setosa setosa setosa setosa setosa setosa ## [13] setosa setosa setosa setosa setosa setosa ## [19] setosa setosa setosa setosa setosa setosa ## [25] setosa setosa setosa setosa setosa setosa ## [31] setosa setosa setosa setosa setosa setosa ## [37] setosa setosa setosa setosa setosa setosa ## [43] setosa setosa setosa setosa setosa setosa ## [49] setosa setosa versicolor versicolor versicolor versicolor ## [55] versicolor versicolor versicolor versicolor versicolor versicolor ## [61] versicolor versicolor versicolor versicolor versicolor versicolor ## [67] versicolor versicolor versicolor versicolor versicolor versicolor ## [73] versicolor versicolor versicolor versicolor versicolor versicolor ## [79] versicolor versicolor versicolor versicolor versicolor versicolor ## [85] versicolor versicolor versicolor versicolor versicolor versicolor ## [91] versicolor versicolor versicolor versicolor versicolor versicolor ## [97] versicolor versicolor versicolor versicolor virginica virginica ## [103] virginica virginica virginica virginica virginica virginica ## [109] virginica virginica virginica virginica virginica virginica ## [115] virginica virginica virginica virginica virginica virginica ## [121] virginica virginica virginica virginica virginica virginica ## [127] virginica virginica virginica virginica virginica virginica ## [133] virginica virginica virginica virginica virginica virginica ## [139] virginica virginica virginica virginica virginica virginica ## [145] virginica virginica virginica virginica virginica virginica ## Levels: setosa versicolor virginica dtiris[, Species] ## [1] setosa setosa setosa setosa setosa setosa ## [7] setosa setosa setosa setosa setosa setosa ## [13] setosa setosa setosa setosa setosa setosa ## [19] setosa setosa setosa setosa setosa setosa ## [25] setosa setosa setosa setosa setosa setosa ## [31] setosa setosa setosa setosa setosa setosa ## [37] setosa setosa setosa setosa setosa setosa ## [43] setosa setosa setosa setosa setosa setosa ## [49] setosa setosa versicolor versicolor versicolor versicolor ## [55] versicolor versicolor versicolor versicolor versicolor versicolor ## [61] versicolor versicolor versicolor versicolor versicolor versicolor ## [67] versicolor versicolor versicolor versicolor versicolor versicolor ## [73] versicolor versicolor versicolor versicolor versicolor versicolor ## [79] versicolor versicolor versicolor versicolor versicolor versicolor ## [85] versicolor versicolor versicolor versicolor versicolor versicolor ## [91] versicolor versicolor versicolor versicolor versicolor versicolor ## [97] versicolor versicolor versicolor versicolor virginica virginica ## [103] virginica virginica virginica virginica virginica virginica ## [109] virginica virginica virginica virginica virginica virginica ## [115] virginica virginica virginica virginica virginica virginica ## [121] virginica virginica virginica virginica virginica virginica ## [127] virginica virginica virginica virginica virginica virginica ## [133] virginica virginica virginica virginica virginica virginica ## [139] virginica virginica virginica virginica virginica virginica ## [145] virginica virginica virginica virginica virginica virginica ## Levels: setosa versicolor virginica # 3. Cuando el segundo argumento es un conjunto de columnas, se puede pasar una # lista de expresiones sin comillas iris[, c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;)] %&gt;% head ## Sepal.Length Sepal.Width ## 1 5.1 3.5 ## 2 4.9 3.0 ## 3 4.7 3.2 ## 4 4.6 3.1 ## 5 5.0 3.6 ## 6 5.4 3.9 dtiris[, list(Sepal.Length, Sepal.Width)] %&gt;% head ## Sepal.Length Sepal.Width ## 1: 5.1 3.5 ## 2: 4.9 3.0 ## 3: 4.7 3.2 ## 4: 4.6 3.1 ## 5: 5.0 3.6 ## 6: 5.4 3.9 # 4. En un contexto de data.table, el . significa lista dtiris[, .(Sepal.Length, Sepal.Width)] %&gt;% head ## Sepal.Length Sepal.Width ## 1: 5.1 3.5 ## 2: 4.9 3.0 ## 3: 4.7 3.2 ## 4: 4.6 3.1 ## 5: 5.0 3.6 ## 6: 5.4 3.9 "],
["tidy-data.html", "5 Tidy Data 5.1 Necesidad de ordenar la información antes del análisis 5.2 Formatos Wide (ancho) and Long (largo)", " 5 Tidy Data “Todos los tidy datasets se parecen unos a otros, pero todos los untidy datasets lo son a su manera.” — Hadley Wickham 5.1 Necesidad de ordenar la información antes del análisis Los que han trabajado analizando datos recordarán que una de las grandes dificultades es la limpieza de los mismos. Sin embargo otra práctica escencial que no se debe olvidar antes de poder realizar cualquier tipo de cálculo o análisis es su ordenamiento. Esta sección se dedicará a explicar la filosofía del tidy data, la cual consiste en exponer una forma de ordenar los datos a través de reorganizar los distintos datos que se puedan encontrar en el día a día. Primero introduciremos algunos terminos para poder ejemplificar mejor algunos de los problemas más comunes en la organización de los datos. 5.1.1 Definiciones Dataset: Colección de valores, los cuales pertenecen a una observación y a una variable. Normalmente se encuentran registrados de manera tabular con filas y columnas. Variable: Contiene todos los valores que miden la misma característica de las “unidades de medición”, i.e. peso, altura, temperatura, etc… Observación: Contiene todos los valores medidos de una “unidad de medición” a través de las diferentes variables. Tidy dataset: Llamaremos tidy u ordenado a un dataset que cumpla con los siguientes tres principios en su estructura: Cada variable es una columna. Cada observación es un renglón. Cada tipo de unidad de medición forma una tabla. 5.1.2 ¿Cuáles son los posibles problemas de estos datos? Algunas de las causas para que estos datos no cuenten con el formato adecuado: Los encabezados de las columnas son variables. Múltiples variables son guardadas en una sola columna. Las variables son guardadas en renglones y no en columnas. A continuación se presentan algunos ejemplos de tablas “desorganizados”. Table 5.1: Información Médica persona tratamiento_a tratamiento_b Joel Sosa 12 NA Alfredo Jiménez 15 17 Alberto Negrete 16 22 La tabla 5.1 muestra datos de tres individuos, con respecto a dos tratamientos médicos. Se puede apreciar como las dos columnas de la tabla se muestran etiquetas de variables. Table 5.2: Información del clima X id year month element d1 d2 d3 d4 d5 1 MX000017004 2010 1 TMAX NA NA NA NA NA 2 MX000017004 2010 1 TMIN NA NA NA NA NA 3 MX000017004 2010 2 TMAX NA 273 241 NA NA 4 MX000017004 2010 2 TMIN NA 144 144 NA NA 5 MX000017004 2010 3 TMAX NA NA NA NA 321 6 MX000017004 2010 3 TMIN NA NA NA NA 142 Este conjunto de datos representa la información meteorológica, temperatura mínima y máxima de los primeros tres meses del 2010. En 5.2 se presenta la columna element con dos indicadores de variables, la temperatura máxima y la mínima así mismo un ordenamiento para los días de cada mes hacia la derecha que hace dificil elaborar cálculos para el análisis. 5.1.3 Ejercicio: Identificar el data set Table 5.3: INPC base Julio 2018 mes 2014 2015 2016 2017 2018 enero 84.51905 87.11010 89.38638 93.60388 98.79500 febrero 84.73316 87.27538 89.77778 94.14478 99.17137 marzo 84.96529 87.63072 89.91000 94.72249 99.49216 abril 84.80678 87.40384 89.62528 94.83893 99.15485 mayo 84.53558 86.96737 89.22561 94.72549 98.99408 junio 84.68207 87.11311 89.32403 94.96364 99.37646 julio 84.91496 87.24082 89.55691 95.32274 99.90910 agosto 85.21997 87.42488 89.80933 95.79377 100.49200 septiembre 85.59634 87.75242 90.35774 96.09352 NA octubre 86.06963 88.20392 90.90615 96.69827 NA noviembre 86.76378 88.68547 91.61683 97.69517 NA diciembre 87.18898 89.04682 92.03903 98.27288 NA Finalmente en la tabla 5.3 se muestra la revalorización del INPC hecha por el INEGI el pasado mes de agosto. ¿Qué podríamos decir de este conjunto de datos? Si quisieramos obtener el crecimiento porcentual entre cada periodo, ¿es conveniente el formato que tiene actualmente? ¿Qué modificaciones le deberíamos hacer a la estructura de la tabla para que sea un conjunto de datos tidy? 5.2 Formatos Wide (ancho) and Long (largo) Como su nombre lo indica, los datos que se encuentran en un formato Ancho son aquellos que contienen información para una misma medida en diferentes columnas. El nombre de las columnas indica la variabla de la cual se está recolectando la información. Un claro ejemplo de datos anchos es la tabla 5.3 En cambio los datos en formato Largo son aquellos que utilizan columnas independientes para guardar las variables de cada observación. Se presenta la siguiente tabla como un ejemplo de cómo se ve la transformación de una tabla Ancha a un formato Largo. Table 5.4: INPC base Julio 2018 formato largo TIME_PERIOD OBS_VALUE 2014-01-01 84.51905 2014-02-01 84.73316 2014-03-01 84.96529 2014-04-01 84.80678 2014-05-01 84.53558 2014-06-01 84.68207 2014-07-01 84.91496 2014-08-01 85.21997 2014-09-01 85.59634 2014-10-01 86.06963 2014-11-01 86.76378 2014-12-01 87.18898 2015-01-01 87.11010 2015-02-01 87.27538 2015-03-01 87.63072 2015-04-01 87.40384 2015-05-01 86.96737 2015-06-01 87.11311 2015-07-01 87.24082 2015-08-01 87.42488 2015-09-01 87.75242 2015-10-01 88.20392 2015-11-01 88.68547 2015-12-01 89.04682 2016-01-01 89.38638 2016-02-01 89.77778 2016-03-01 89.91000 2016-04-01 89.62528 2016-05-01 89.22561 2016-06-01 89.32403 2016-07-01 89.55691 2016-08-01 89.80933 2016-09-01 90.35774 2016-10-01 90.90615 2016-11-01 91.61683 2016-12-01 92.03903 2017-01-01 93.60388 2017-02-01 94.14478 2017-03-01 94.72249 2017-04-01 94.83893 2017-05-01 94.72549 2017-06-01 94.96364 2017-07-01 95.32274 2017-08-01 95.79377 2017-09-01 96.09352 2017-10-01 96.69827 2017-11-01 97.69517 2017-12-01 98.27288 2018-01-01 98.79500 2018-02-01 99.17137 2018-03-01 99.49216 2018-04-01 99.15485 2018-05-01 98.99408 2018-06-01 99.37646 2018-07-01 99.90910 2018-08-01 100.49200 Existen dos operaciones fundamentales para transformar la estructura de la tabla melt() y cast(). melt(): Sirve para agrupar las variables que se encuentran en columnas cast(): Estas operaciones pueden presentarse con otros nombres, dependiendo de la paquetería que utilicen; con dplyr las funciones son gather() y spread(), en data.table utilizaremos melt.data.table() y dcast.data.table() y finalmente las que usaremos en los siguientes ejercicios se encuentran en el paquete reshape2 son melt() y dcast(). Pueden consultar el siguiente enlace en Data_Camp para reforzar los conceptos. El siguiente video es un resumen completo de lo que hemos visto hasta ahora. "]
]
